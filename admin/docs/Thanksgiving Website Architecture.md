# Thanksgiving Website Architecture

Bob Maguire  
September 2025

# Purpose

* The purpose of this document is to explain the structure and design of the Thanksgiving Website that I am building to document our Thanksgiving Memories.

# Languages and Frameworks

## Client Side:

* HTML  
* CSS  
* Javascript  
* Front End Design: I had the cursor AI use this site: [https://www.latimes.com/food](https://www.latimes.com/food) as the basis for the design.  This is what the Cursor AI provided back as how it interpreted the website design and how it applied it:
[This is an external link to the AI design](https://docs.google.com/document/d/1ZhxPDd1stLJUR1cS805fHUlQ8YtnuGDY-7RIhsbWutU/edit?usp=sharing)


## Server Side:

* Node.JS  
* Express (Web Server)  
* Sequelizer  
* PoestgreSQL  
* Backend Design: I asked cursor to analyze the original website and make recommendations to make it better.  Here was its response:

| ðŸ“Š Code Analysis & Improvement Suggestions After analyzing your Thanksgiving menu application, here are the key areas for improvement: Current Issues: âŒ Monolithic server.js \- All routes and logic in one file âŒ No separation of concerns \- Business logic mixed with routing âŒ Repetitive error handling \- Same error handling code duplicated âŒ No input validation \- No validation on route parameters âŒ No caching \- Database queries on every request âŒ No environment configuration \- Hardcoded values âŒ No logging system \- Basic console.log only âŒ No API versioning \- API routes not versioned Better Architecture Suggestions: New Modular Structure: thanksgiving/ â”œâ”€â”€ src/ â”‚   â”œâ”€â”€ controllers/ â”‚   â”‚   â””â”€â”€ menuController.js      \# Request/response handling â”‚   â”œâ”€â”€ services/ â”‚   â”‚   â””â”€â”€ menuService.js         \# Business logic â”‚   â”œâ”€â”€ middleware/ â”‚   â”‚   â”œâ”€â”€ errorHandler.js        \# Centralized error handling â”‚   â”‚   â””â”€â”€ validation.js          \# Input validation â”‚   â”œâ”€â”€ routes/ â”‚   â”‚   â”œâ”€â”€ menuRoutes.js          \# Web routes â”‚   â”‚   â””â”€â”€ apiRoutes.js           \# API routes â”‚   â””â”€â”€ utils/ â”‚       â”œâ”€â”€ constants.js           \# Application constants â”‚       â””â”€â”€ helpers.js             \# Utility functions â”œâ”€â”€ config/ â”‚   â”œâ”€â”€ app.js                     \# App configuration â”‚   â””â”€â”€ database.js                \# Database configuration â””â”€â”€ server.js                      \# Main application file  ï¿½ï¿½ 2\. Improved Code Examples Better Controller Pattern: javascript // src/controllers/menuController.js const menuService \= require('../services/menuService'); const { validationResult } \= require('express-validator'); class MenuController {   async getAllMenus(req, res, next) {     try {       const { sort \= 'desc', limit } \= req.query;       const menus \= await menuService.getAllMenus({ sort, limit });       res.render('index', {          title: 'Thanksgiving Menus Through the Years',         events: menus        });     } catch (error) {       next(error);     }   }   async getMenuById(req, res, next) {     try {       const { id } \= req.params;       const menu \= await menuService.getMenuById(id);              if (\!menu) {         return res.status(404).render('error', {            message: 'Menu not found',           error: 'The requested menu could not be found.'          });       }              res.render('detail', {          title: menu.menu\_title,         event: menu        });     } catch (error) {       next(error);     }   } } module.exports \= new MenuController(); Service Layer: javascript // src/services/menuService.js const { Event } \= require('../models'); const { Op } \= require('sequelize'); class MenuService {   async getAllMenus(options \= {}) {     const { sort \= 'desc', limit } \= options;          return await Event.findAll({       order: \[\['event\_date', sort.toUpperCase()\]\],       limit: limit ? parseInt(limit) : undefined,       attributes: \['event\_id', 'event\_name', 'event\_type', 'event\_location',                    'event\_date', 'event\_description', 'menu\_title', 'menu\_image\_filename'\]     });   }   async getMenuById(id) {     return await Event.findByPk(id);   }   async getMenusByYear(year) {     return await Event.findAll({       where: {         event\_date: {           \[Op.between\]: \[\`${year}\-01-01\`, \`${year}\-12-31\`\]         }       },       order: \[\['event\_date', 'DESC'\]\]     });   } } module.exports \= new MenuService(); Better Error Handling: javascript // src/middleware/errorHandler.js const errorHandler \= (err, req, res, next) \=\> {   console.error(err.stack);   // Sequelize errors   if (err.name \=== 'SequelizeDatabaseError') {     if (err.original.code \=== '42P01') {       return res.status(500).render('error', {          message: 'Database table not found',         error: 'Please run the database setup script.'        });     }   }   // Validation errors   if (err.name \=== 'ValidationError') {     return res.status(400).json({ error: err.message });   }   // Default error   res.status(500).render('error', {      message: 'Something went wrong\!',     error: process.env.NODE\_ENV \=== 'development' ? err.message : 'Internal server error'   }); }; module.exports \= errorHandler; Input Validation: javascript // src/middleware/validation.js const { body, param, query } \= require('express-validator'); const validateMenuId \= \[   param('id').isInt({ min: 1 }).withMessage('Menu ID must be a positive integer'), \]; const validateQueryParams \= \[   query('sort').optional().isIn(\['asc', 'desc'\]).withMessage('Sort must be asc or desc'),   query('limit').optional().isInt({ min: 1, max: 100 }).withMessage('Limit must be between 1 and 100'), \]; module.exports \= { validateMenuId, validateQueryParams }; Better Route Organization: javascript // src/routes/menuRoutes.js const express \= require('express'); const menuController \= require('../controllers/menuController'); const { validateMenuId, validateQueryParams } \= require('../middleware/validation'); const router \= express.Router(); router.get('/', validateQueryParams, menuController.getAllMenus); router.get('/menu/:id', validateMenuId, menuController.getMenuById); module.exports \= router; ðŸŽ¯ 3\. Key Improvements Performance: âœ… Caching \- Redis for frequently accessed data âœ… Database indexing \- Index on event\_date for faster queries âœ… Pagination \- Limit results for better performance âœ… Image optimization \- WebP format, lazy loading Security: âœ… Input validation \- Validate all user inputs âœ… Rate limiting \- Prevent abuse âœ… CORS configuration \- Proper CORS setup âœ… Environment variables \- No hardcoded secrets Maintainability: âœ… Separation of concerns \- Controllers, services, models âœ… Error handling \- Centralized error management âœ… Logging \- Structured logging with Winston âœ… Testing \- Unit and integration tests Scalability: âœ… API versioning \- /api/v1/events âœ… Database connection pooling \- Better connection management âœ… Microservices ready \- Easy to split into services âœ… Docker support \- Containerization ðŸ”§ 4\. Quick Wins (Easy to implement now): Add input validation for route parameters Extract routes into separate files Add proper error handling middleware Add environment configuration for different environments Add basic logging with timestamps Add API response caching for static data |
| :---- |

I had it implement 1 & 2\.  Here were the results:

| ðŸŽ¯ Key Improvements: 1\. Separation of Concerns: Controllers: Handle HTTP requests/responses Services: Contain business logic Middleware: Handle cross-cutting concerns Routes: Define API endpoints Utils: Reusable helper functions 2\. Better Error Handling: âœ… Centralized error handling with specific error types âœ… Database error detection (table not found, connection issues) âœ… Validation error handling with detailed messages âœ… API vs Web error responses (JSON vs HTML) âœ… Development vs Production error details 3\. Input Validation: âœ… Route parameter validation (menu ID, year) âœ… Query parameter validation (sort, limit) âœ… Custom validation middleware with error handling âœ… Sanitized inputs to prevent injection attacks 4\. Enhanced API: âœ… Versioned API endpoints (/api/v1/events) âœ… Standardized JSON responses with success/error format âœ… New endpoints: /stats, /year/:year âœ… Query parameters: ?sort=desc\&limit=10 5\. Configuration Management: âœ… Environment-based configuration âœ… Database connection pooling âœ… Request size limits âœ… Graceful shutdown handling ðŸš€ New Features Available: API Endpoints: shellscript \# Get all menus GET /api/v1/events \# Get specific menu GET /api/v1/events/:id \# Get menus by year GET /api/v1/events/year/:year \# Get statistics GET /api/v1/stats \# Health check GET /health Query Parameters: shellscript \# Sort and limit results GET /api/v1/events?sort=asc\&limit=5 \# Legacy endpoint still works GET /api/events Web Routes: shellscript \# Home page with all menus GET / \# Individual menu detail GET /menu/:id \# Menus by year GET /year/:year ðŸ”§ Testing Results: âœ… Server starts successfully with new structure âœ… Health endpoint returns proper status âœ… API endpoints return standardized JSON âœ… Error handling works for invalid IDs âœ… Statistics endpoint shows 26 menus (1994-2024) ðŸ“ˆ Benefits Achieved: Maintainability: Code is now organized and easy to modify Scalability: Easy to add new features and endpoints Reliability: Better error handling and validation Developer Experience: Clear separation of concerns API Design: RESTful endpoints with proper responses Security: Input validation and sanitization Monitoring: Health checks and structured logging The application now follows industry best practices and is ready for production deployment\! ðŸŽ‰ |
| :---- |

